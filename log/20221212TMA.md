## 12월 12일 알고리즘



- **문제 :** 

큰 수의 법칙'은 일반적으로 통제 분야에서 다루어지는 내용이지만 동빈이는 본인만의 방식으로 다르게 사용하고 있다. 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 씨1번더하여 가장 큰 수를 만드는 법칙이다. 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속 해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징이다.
예를 들어 순서대로 2, 4, 5, 4, 6으로 이루어진 배열이 있을 때 M이 8이고, K가 3이라고 가정하자.
이 경우 특정한 인덱스의 수가 연속해서 세 번까지만 더해질 수 있으므로 큰 수의 법칙에 따른 결과는 6+ 6+ 6+5 + 6+ 6 + 6 + 5인 46이 된다.
단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다. 예를 들어 순서 대로 3, 4, 3. 4, 3으로 이루어진 배열이 있을 때 M이 7이고, K가 2라고 가정하자. 이 경우 두 번째 원소에 해당하는 4와 네 번째 원소에 해당하는 4를 번갈아 두 번씩 더하는 것이 가능하다. 결과적으 로4+4+4+4+4+ 4+ 4인 28이 도출된다.
배열의 크기 N, 숫자가 더해지는 횟수 M, 그리고 K가 주어질 때 동빈이의 큰 수의 법칙에 따른 결과를 출력하시오.



- 입력 조건 :

  -  첫째 줄에 N(2 ≤ N ≤ 1,000) M(1 ≤ M ≤ 10,000), K(1 s K ≤ 10,000)의 자연수가 주어 지며, 각 자연수는 공백으로 구분한다.
  -  둘째 줄에 N개의 자연수가 주어진다. 각 자연수는 공백으로 구분한다. 단, 각각의 자연수는 1 이상 10,000 이하의 수로 주어진다.
  -  입력으로 주어지는 K는 항상 M보다 작거나 같다.

- 출력 조건 : 

  - 첫째 줄에 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력한다.

- 입력 예시 :

  ``` 
  5 8 3
  2 4 5 4 6
  ```

- 출력 예시 : 46



---------

### 내가 짠 코드

```python
N, M, K = map(int, input().split())  # 정수형으로 값 입력 받기, 스페이스바로 값 연속으로 받기
A = 0  # 정답이 될 변수
count = 0  # 연속 연산 횟수
# 각 변수들의 범위
if (2 >= N) and (N >= 1000):
    print('N의 범위가 잘못되었습니다.')

if (M <= 1) and (M >= 10000):
    print('M의 범위가 잘못되었습니다.')

if (K <= 2) and (K >= 10000):
    print('K의 범위가 잘못되었습니다.')

N_list = list(map(int, input().split()))  # map 함수를 쓰면 for 문을 안써도 한번에 배열 입력이 가능하대

# 연산 과정
for i in range(M - 1):  # M-1번 연산
    A += max(N_list)  # 가장 큰 수를 우선적으로 연산
    count += 1  # 연산 후 횟수 +1
    if count == K:  # 연속 연산이 K번과 동일해지면
        temp = max(N_list)  # 잠시 가장 큰 수를 저장하고
        N_list.remove(temp)  # 뺀다 (remove() : "입력한 값을 검색해서, 첫 번째 검색 결과를 삭제")
        A += max(N_list)  # 그리고 그 다음으로 큰 수 하나를 연산
        count = 0  # 연속 연산 초기화
        N_list.append(temp)  # 다시 원래 가장 큰수 리스트에 추가

print(A)

```



### 단순하게 푼 코드

 

단순하게 짠 코드 같은 경우 M의 수가 100억을 넘어가면 시간 초과를 판정받는다(본 문제 같은 경우는 10,000이하를 다루므로 정답가능)

```python
n, m, k = maplint, input().split())
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))
data.sort() # 입력받은 수들 정렬하기 first = dataln -1] # 가장 큰 수 second = dataln - 2] #두 번째로 큰 수
result = 0
while True:
	for i in range(k): # 가장 큰 수를 K번 더하기
		if m == 0: # mol 0이라면  반복문 탈출
			break
		result += first
		m == 1 # 더할 때마다 1씩 빼기
	if m == 0: # mol 0이라면 반복문 탈출
		break
	result += second # 두 번째로 큰 수를 한 번 더하기
	m -= 1# 더할 때마다 1씩 빼기

print(result) # 최종 답안 출력
```



### 수정된 정답

수학적으로 생각을 전환해서 좀 더 효율이 높게 문제를 이해해보자.

해당 문제는 가장 큰 수(이하 max)와 두번째로 높은 수(sec_max)만을 다룬다. 

그리고 N M K 중 K는 가장 큰 수를 연속적으로 더할 수 있는 횟수이고, 그 후 반드시 sec_max를 한 번 꼭 더해줘야한다.

예시를 들면 	N = 5 	M =8 	K = 3	이고 리스트가 N_list = [2 3 8 6 9] 이라면 연산식은 다음과 같다.

(9+9+9+8) + (9+9+9+8) 이다. 이 식을 좀 더 변형시키면 (9+9+9+9+9+9) + (8+8)  = 9 * 6 + 8 * 2

max를 곱하는 횟수 와 sec_max를 곱하는 횟수가 나뉘는 모습을 볼 수 있다.

각각의 횟수를 알면 하나의 간단한 식으로 정리가 되므로 횟수를 아는 부분이 중요하다.

반복되는 수열은 9 9 9 8인데, 이때  수열의 크기 - 1 = K => K+1 = 수열의 크기, 그리고

M / 수열의 크기 = 수열의 반복 횟수, 수열의 반복 횟수 * K = max를 곱하는 횟수가 된다.

또한 반복 횟수가 딱 나눠떨어지지 않는 경우는 M / 수열의 크기 의 나머지에 해당하므로 M % (K+1)을 따로 찾아서 max 곱 횟수에 더해준다. sec_max를 곱하는 횟수는 전체에서 max 곱 횟수의 나머지에 속하므로 전체식을 정리하면 다음과 같다.



max 곱 횟수 = (M / (K+1)) * K + M % (K+1)

sec_max 곱 횟수 = M -  max 곱 횟수

=> max * { (M / (K+1)) * K + M % (K+1) } + sec_max * (M -  max 곱 횟수)

그리고 이를 반영한 코드는 아래와 같다.

```python
# N, M, K를 공백으로 구분하여 입력받기 n, m, k= map(int, input().split()
# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input() split())
data.sort() # 입력받은 수 정렬 first = dataln - 1] # 가장 큰 수 second = dataln - 2]# 두 번째로 큰 수
# 가장 큰 수가 더해지는 횟수 계산
count = int(m/ (k+1)) *k
count += m ° (k + 1)
result = 0
result+= (count) * first # 가장 큰 수 더하기
result += (m - count) * second # 두 번째로 큰 수 더하기
print(result) # 최종 답안 출력
```





## 고찰

이전에 학교에서 기타 과제로 C언어를 이용하여 알고리즘 문제를 푼 적은 있지만, 파이썬을 이용해서 코딩 테스트 문제를 풀어본 적은 오늘이 처음이었다. 가장 난이도가 낮은 문제라고 하는데 문법부터 해서 해당 문제의 규칙을 찾는 과정이 상당히 오래걸렸다.

제한시간은 30분이지만 과연 실제 상황에서 이걸 30분 안에 풀 수 있을지 모르겠다.

더 열심히 공부해야겠다 정말로.