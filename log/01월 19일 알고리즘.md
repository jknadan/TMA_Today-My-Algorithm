## 01월 19일 알고리즘



#### 문제

N x M 크기의 얼음 틀이 있다. 구멍이 뚫려 있는 부분은 0, 칸막이가 존재하는 부분은 1로 표시된 다. 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한 다. 이때 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하는 프로그램을 작성 하시오. 다음의 4 x 5 얼음 틀 예시에서는 아이스크림이 총 3개 생성된다.



|  0   |  0   |  1   |  1   |  0   |
| :--: | :--: | :--: | :--: | :--: |
|  0   |  0   |  0   |  1   |  1   |
|  1   |  1   |  1   |  1   |  1   |
|  0   |  0   |  0   |  0   |  0   |






#### 입력조건

• 첫 번째 줄에 얼음 틀의 세로 길이 N과 가로 길이 M이 주어진다. (1 ≤ N, M ≤ 1,000)
• 두 번째 줄부터 N + 1 번째 줄까지 얼음 틀의 형태가 주어진다.
• 이때 구멍이 뚫려있는 부분은 0, 그렇지 않은 부분은 1이다.

#### 출력조건

• 한 번에 만들 수 있는 아이스크림의 개수를 출력한다.

##### 입력 예시

```
15 14
00000111100000
11111101111110
11011101101110
11011101100000
11011111111111
11011111111100
11000000011111
01111111111111
00000000011111
01111111111000
00011111111000
00000001111000
11111111110011
11100011111111
11100011111111
```





##### 출력 예시

```
8
```





--------



### 내가 짠 코드

```python
# N, M을 공백으로 구분하여 입력받기
N, M = map(int, input().split())

# 방문한 위치를 저장하기 위한 맵을 생성하여 0으로 초기화
tray = [[0] * M for _ in range(N)]

# 그래프를 저장하기 위한 2차원 배열
count = [[]]

dx = [1,-1,0,0]
dy = [0,0,1,-1]

def DFS(graph,x,v,visited) :
    visited[v] = True
    global count
    count[x].append(v)
    for k in graph[v]:
        if not visited[k]:
            DFS(graph, x, k, visited)

def check(x,y):
    global count
    for h in range(4):
        nx = x + dx[h]
        ny = y + dy[h]
        if tray[nx,ny] == 0 and count


# 전체 노드 탐색
for i in range(N):
    for j in range(M):


################################################# 풀이 중단 #####################################################
```

해당 DFS 문제에서는 답도 없이 어디서부터 어떻게 접근을 해야할지 막막했다.

dfs 탐색 함수의 기본적인 예시는 이해했지만, 이를 이 문제에 어떻게 적용,변형해야할지도 의문이었다.

어떻게든 문제를 풀려고 애를 써봤지만, 업무 시간이 초과하면서까지 문제를 잡고 있는 것은 회사에 피해라고 생각했고, 우선 문제 풀이를 중단했다.

문제를 풀기 위해 자존심까지 버려가며 문제에 대한 힌트를 봤지만, 여전히 이를 어떻게 코드로 구현해야할지는 막막했다.

우선 내가 생각한 문제 해결 과정은 다음과 같다.

1. 모든 노드를 순차적으로 탐색하며 상,하,좌,우에 인접한 노드가 있는지 확인한다.
2. 인접 노드가 0 이고 **아직 탐색하지 않은 부분**이라면 해당 노드로 이동하기 전에 **현재 노드에서 탐색 가능함을 확인**했던 노드들을 인접리스트 형태로 저장하고 이동한다.
3. 이동한 인접 노드에서도 1번을 반복하다가 더 이상 탐색할 수 없다면, 이때까지 탐색했던 그래프 형태를 count 2차원 배열의 첫번째 원소로 append한다.
4.  N 방향으로 탐색을 모두 종료했을 때 저장된 count의 길이를 센다.
5. 정답으로 출력한다.



그리고 굵은 글씨로 표시한 고려해야할 사항은 다음과 같다.

- "아직 탐색하지 않은 부분" = 아직 탐색하지 않았다는 사실을 어디서 어떻게 알 수 있는가? 변수로 따로 분리해서 확인한다면.. 어떤 형태의 변수를 선언해야하는가? (count 변수를 3차원으로 선언해서 인접리스트형태로 넣을때,각 행과열에 해당하는 인덱스를 넣어서 조사하고 True False 여부를 판단해야하는가?)
- "현재 노드에서 탐색 가능함을 확인했던" = 현재 노드에서 탐색 가능함을 확인하는 방법은? 현재로써는 현재 위치에서 상하좌우 dx,dy 값을 더해서 해당 위치가 0인지 탐색하지 않은 부분인지 확인하는 for문을 선언해야하나 싶다.



답안은 확인하지 않았다. 계속해서 답안을 확인하다가는 내 실력이 늘지 않을 것 같았다.



### 답안



```python

```









### 고찰

개인적인 고찰이지만, 아직 코테를 풀기에 너무 기본도 없는 상황이라 한문제 한문제가 오래걸리고 버겁다. 원래 잡아놓은 시간인 1시간40분을 훨씬 초과해버리니 (물론 파트가 변하는 부분이라 개념학습에도 시간이 걸리긴했음) 업무에 지장이 있을 것 같아서 시간을 옮겨야겠다. 퇴근 후나...언제하지 ...근데...